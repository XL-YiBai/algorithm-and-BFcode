## 事件循环与任务队列
首先看一段js代码：

```js
setTimeout(() => console.log(1), 0);
console.log(2);
```

这段代码的执行结果为先输出2，后输出1。



### 事件循环(Event Loop)

![js异步中的任务队列](E:\中南林业科技大学\前端冲冲冲\学习JavaScript数据结构与算法\截图\js异步中的任务队列.png)

一段js代码刚执行的时候会有一个匿名的主事件，会进入任务队列(Callback Queue)中，js引擎会去任务队列中取一个事件来执行,因为js是单线程的，所以每次只能处理一个事件，在执行当前事件过程中，如果里面有异步任务(比如Dom操作，ajax请求，定时器等等)，就会丢给webapi来执行，js引擎就不管了。
WebAPI执行异步任务结束时，会把回调函数中的js代码再放入任务队列(Callback Queue)中，当任务队列中前面的事件都执行完了之后，这个回调函数就会继续进入js引擎中执行，如果这个回调函数中还有异步任务就会继续重复这个循环。
这就是事件循环



### 解释代码

因此最开始那段代码是这样执行的，首先这段代码刚执行会有一个主事件放到任务队列中，然后js引擎从任务队列中拿到这个事件去执行，执行到setTimeout时，发现这是一个异步任务，就把它交给Web Api去执行，js引擎继续执行后面的代码，而Web Api在0毫秒就执行完了定时器，接着把回调函数console.log(1)放入任务队列，但是发现任务队列中还有一个主事件没执行完，因为主事件还有一个console.log(2)没执行，等执行完这句代码后，js引擎执行完主事件，再去任务队列中取出那个回调函数执行，然后输出1，所以这段代码就是先打印2再打印1。